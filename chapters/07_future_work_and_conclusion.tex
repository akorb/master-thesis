% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Conclusion}\label{chapter:future_work_and_conclusion}

In the final chapter, we briefly answer the originally proposed research questions, present some closing thoughts and also indicate directions for possible future research based on our work.

\section{Why we did it?/The problem}

\section{Answering research questions}

% In the \nameref{chapter:introduction} we listed our research questions.

\paragraph{Identity of \ac{fTPM}}
The first question asked what constitutes the identity of an fTPM\@.
We found that it is important for its identity to include its entire underlying software stack.
This is due to the reason that each predecessor directly affects the security of an \ac{fTPM}.
Despite that, it is still not unique.
Therefore, it must also depend on a unique value, which we integrate by involving the \ac{UDS}.
Only by that, its identity can represent uniquely an \ac{fTPM}.

\paragraph{\acs{DICE} \texttt{+} \acs{TPM}}
Next, we provide a design to combine the infrastructures of \ac{DICE} and \ac{TPM}.
Here, the most important point is where the both infrastructures meet.
While \ac{DICE} measures and derives thereon dependent secrets from the start of the device, the \ac{fTPM} is launched later in the boot chain.
When it is eventually executed, it retrieves its \ac{CDI} from \ac{DICE}, which represents the fTPM's identity as understood previously from the perspective of \ac{DICE}.
Based on that, the \ac{fTPM} derives its \ac{EPS}, which is the root seed for its \ac{EK}, which represents its identity from the perspective of \acp{TPM}.
In short, the infrastructures meet and are combined at the step from the \ac{CDI} (DICE) to the \ac{EPS} (TPM).

\paragraph{Manage the fTPM's data securely}
Another important question to take care of is what involves managing the fTPM's data securely.
The underlying question is what \emph{securely} means in this context.
On the one hand, you want to make the data from the fTPM as widely available as possible; on the other hand, the data should be linked as closely as possible to the fTPM\@.
We thereby choose to bind the data to an fTPM as long as its security relevant factors to not change, whether for the better or for the worse.
This matches with our definition of the fTPM's identity, which is constant as long as the underlying firmware does not change, which directly affects the fTPM's security.
Hence, we derive a storage key from the fTPM's \ac{CDI}, with which we protect the confidentiality and integrity of its data.


\paragraph{Privacy}

% • How to combine the DICE and TPM infrastructure?
% • How to manage an fTPM’s persistent data securely?
% • How to enable privacy for this attestation mechanism?

\section{Relevance}

\section{Summary}

In this work, we have proposed a novel remote attestation scheme to establish trust in an \ac{fTPM}\@.
\Acp{fTPM} cannot be trusted based on their isolated identity alone, as their underlying software components are also security relevant, unlike \acp{dTPM} which are a separate chip.
We therefore use the \ac{DICE} as a hardware root of trust and measure each component during the boot process up to the \ac{fTPM}\@.
The verifier can thus learn the measurements of the corresponding components and decide whether they are classified as trustworthy.
These measurements are transmitted from the prover to the verifier in the form of certificates.
It is in the nature of certificates that they are not secret and can therefore be easily replayed by malicious provers.
Hence, the verifier must ensure that the certificates correspond to the device it is communicating with.
This is not directly ensured by our system, but should be part of the attestation protocol that runs atop of our system, e.g., the \ac{fTPM} attesting the state of the system with a quote.
To do this, the prover must prove to be in control of the private key that corresponds to the public key part of the certificate that describes the \ac{fTPM}\@.
These keys are unique for the identity of the device (the \ac{UDS}) and the identities of the individual components (the \acp{TCI}) and therefore cannot be generated by other, potentially malicious, verifiers.
We concluded the presentation of our system with an explanation of a proof-of-concept implementation and a discussion of the feasibility, caveats and limitations of the system.

We believe that our system is an important step towards the independence of the manufacturer of the \ac{fTPM} and its upstream software, whereas today verifiers trust a single manufacturer who is assumed to have provided all these components.
Our system also creates a hardware root of trust for the \ac{fTPM} which, as the name suggests, cannot be provided by the \ac{fTPM} as it is a software component.
In contrast, \acp{dTPM} are capable of acting as a hardware root of trust.
Our system closes this gap.


\section{Future Work}

The logical consequence is the implementation of our solution on real hardware instead of in a simulation environment such as FVP\@.
This allows the interaction with the hardware to be verified, especially with an RPMB partition that requires hardware support.
In addition, the impact of our solution on the performance of the system can then be measured in practice.
This is especially interesting since we integrate another storage encryption.

Although it makes sense to show our solution on Arm hardware first, we are, as mentioned, not limited to it.
Therefore, a future work is to concretize the description of our implementation for TEE technologies other than Arm, e.g. Intel~SGX\@.

The system we propose can also be transferred from the DICE architecture to other technologies that also perform firmware measurements.
A new technological framework that generalizes DICE is Caliptra~\cite{caliptra}.
It is based on the concept of DICE, but is not limited to it.

As mentioned in \autoref{sec:arch_overview}, RPMB's rollback protection only protects against attacks from outside the TEE\@.
We would like to establish a design that tightens the rollback protection from the trust of the entire TEE to the identity of the fTPM\@.
This can probably be achieved by encrypting the metadata stored on the RPMB with the storage key derived from the identity of the fTPM, i.e., its CDI, before sending it to the RPMB\@.
This must be implemented in the trusted operating system and not in the fTPM TA, as the trusted operating system normally manages the metadata.

Furthermore, our solution does not protect against runtime attacks on the fTPM\@.
In general, \acp{TA} in a TEE are not resistant to security problems caused by programming errors, e.g., buffer overflow attacks.
Therefore, remote attestation of the control flow integrity of the fTPM may be a desired function.
Displaying the current state of the fTPM instead of its identity at boot time would be a useful extension to our solution.

% We described in \autoref{sec:impl_ftpm_attestation} the new fTPM TA command \texttt{TA\_FTPM\_ATTEST}.
% Instead store the certificate chain in the NV indices provided by EK profile.
% We didn't do it because it does not benefit the demonstration of our system, but requires much engineering effort. For example, tpm2_getekcertificate does not support that.
% But it would greatly simplify our solution. But it also takes NV index storage space, which is now not taken. But the fTPM still takes more space.
