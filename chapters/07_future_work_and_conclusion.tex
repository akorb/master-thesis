% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Conclusion}\label{chapter:future_work_and_conclusion}

In the final chapter, we briefly answer the originally proposed research questions, present some closing thoughts and also indicate directions for possible future research based on our work.

\section{Revisiting the research questions}

% In the \nameref{chapter:introduction} we listed our research questions.

\paragraph{Identity of \ac{fTPM}}
The first question asked is what constitutes the identity of an fTPM\@.
We found that it is important for its identity to include its entire underlying software stack.
This is due to the reason that each predecessor directly affects the security of an \ac{fTPM}.
Despite that, it is still not unique.
Therefore, it must also depend on a unique value, which we integrate by involving the \ac{UDS}.
Only by that, its identity can represent uniquely an \ac{fTPM}.

\paragraph{\acs{DICE} \texttt{+} \acs{TPM}}
Next, we provide a design to combine the infrastructures of \ac{DICE} and \ac{TPM}.
Here, the most important point is where the both infrastructures meet.
While \ac{DICE} measures and derives thereon dependent secrets from the start of the device, the \ac{fTPM} is launched later in the boot chain.
When it is eventually executed, it retrieves its \ac{CDI} from \ac{DICE}, which represents the fTPM's identity as understood previously from the perspective of \ac{DICE}.
Based on that, the \ac{fTPM} derives its \ac{EPS}, which is the root seed for its \ac{EK}, which represents its identity from the perspective of \acp{TPM}.
In short, the infrastructures meet and are combined at the step from the \ac{CDI} (DICE) to the \ac{EPS} (TPM).

\paragraph{Manage the fTPM's data securely}
Another important question to take care of is what involves managing the fTPM's data securely.
The underlying question is what \emph{securely} means in this context.
On the one hand, you want to make the data from the fTPM as widely available as possible; on the other hand, the data should be linked as closely as possible to the fTPM\@.
We thereby choose to bind the data to an fTPM as long as its security relevant factors to not change, whether for the better or for the worse.
This matches with our definition of the fTPM's identity, which is constant as long as the underlying firmware does not change, which directly affects the fTPM's security.
Hence, we derive a storage key from the fTPM's \ac{CDI}, with which we protect the confidentiality and integrity of its data.

\paragraph{Privacy}

Remote attestation without involving privacy has the benefit of being straightforward, and requiring only the expected parties---verifier and prover.
Despite that, privacy can still be a higher prioritized criteria, such that we also explain an approach to integrate it into our solution.
The short answer to the according research question is that we need a third party \ac{CA} standing between the verifier and the prover.
To elaborate, the prover forwards its \ac{DICE} certificates containing the exact identity of the prover's \ac{fTPM} to the privacy \ac{CA}, which evaluates whether it indeed represents an authentic TPM\@.
It then lets the verifier know that the TPM is authentic, without revealing its identity.
Hence, the verifier can only derive that it communicates with \emph{an} authentic TPM, but not \emph{which}.
Although the verifier can still decide for itself whether it considers the \ac{fTPM} to be trustworthy based on its measurements, the disadvantage of this approach is the required privacy \ac{CA} that must be trusted by the verifier to have correctly assessed the authenticity of the \ac{fTPM}.

% \section{Relevance}



% \section{Summary}

% In this work, we have proposed a novel remote attestation scheme to establish trust in an \ac{fTPM}\@.
% \Acp{fTPM} cannot be trusted based on their isolated identity alone, as their underlying software components are also security relevant, unlike \acp{dTPM} which are a separate chip.
% We therefore use the \ac{DICE} as a hardware root of trust and measure each component during the boot process up to the \ac{fTPM}\@.
% The verifier can thus learn the measurements of the corresponding components and decide whether they are classified as trustworthy.
% These measurements are transmitted from the prover to the verifier in the form of certificates.
% It is in the nature of certificates that they are not secret and can therefore be easily replayed by malicious provers.
% Hence, the verifier must ensure that the certificates correspond to the device it is communicating with.
% This is not directly ensured by our system, but should be part of the attestation protocol that runs atop of our system, e.g., the \ac{fTPM} attesting the state of the system with a quote.
% To do this, the prover must prove to be in control of the private key that corresponds to the public key part of the certificate that describes the \ac{fTPM}\@.
% These keys are unique for the identity of the device (the \ac{UDS}) and the identities of the individual components (the \acp{TCI}) and therefore cannot be generated by other, potentially malicious, verifiers.
% We concluded the presentation of our system with an explanation of a proof-of-concept implementation and a discussion of the feasibility, caveats and limitations of the system.

% We believe that our system is an important step towards the independence of the manufacturer of the \ac{fTPM} and its upstream software, whereas today verifiers trust a single manufacturer who is assumed to have provided all these components.
% Our system also creates a hardware root of trust for the \ac{fTPM} which, as the name suggests, cannot be provided by the \ac{fTPM} as it is a software component.
% In contrast, \acp{dTPM} are capable of acting as a hardware root of trust.
% Our system closes this gap.

\section{Significance and closing thoughts}\label{sec:significance}

We started this work based on the observation that commodity \acp{fTPM} are part of a monolithic, proprietary environment.
Assuming the entire firmware of these CPUs comes from the same manufacturer, understanding and trusting the manufacturer of an \ac{fTPM} can be extended to trusting the entire firmware.
Our thesis aims to break this requirement, and remotely attest the \ac{fTPM} and its underlying firmware independently of their manufacturer.
An \ac{fTPM} cannot act as a hardware root of trust, due to as the name suggests, it is a software component.
In contrast, \acp{dTPM} are capable of acting as a hardware root of trust.
% Instead, we leverage \ac{DICE} as the hardware root of trust to conduct independent measurements of the machine's firmware.
Our system closes this gap by adding an independent hardware root of trust to which trust can be remotely established, i.e., \ac{DICE}, that measures the entire firmware up to the \ac{fTPM}.

% Independence of manufacturer of fTPM and underlying firmware.
% Probably less relevant for proprietary systems like vendored by AMD or Intel, but for open systems maybe built upon RISC-V

% Add independent party to trust, which measures the entire firmware up to the fTPM

We believe that this work is an important step towards the independence of the manufacturer of the \ac{fTPM} and its upstream firmware. %, whereas today verifiers trust a single manufacturer who is assumed to have provided all these components.
Despite not considering this problem relevant for vendors like AMD and Intel whose products are fully single-sourced, we believe this work is of value for open ecosystems, e.g., systems based on RISC-V\@.
Recently, in 2021, an \ac{fTPM} for RISC-V systems was described~\cite{Boubakri2021}, and for the same a \ac{DICE} implementation was proposed in 2023~\cite{Bravi2023}.
This indicates that this ecosystem will continue to evolve and take center stage.

\textbf{In the spirit of zero trust, our system measures, instead of assumes.}

\section{Future Work}

The logical consequence is the implementation of our solution on real hardware instead of in a simulation environment such as FVP\@.
This allows the interaction with the hardware to be verified, especially with an RPMB partition that requires hardware support.
In addition, the impact of our solution on the performance of the system can then be measured in practice.
This is especially interesting since we integrate another storage encryption.

Although it makes sense to show our solution on Arm hardware first, we are, as mentioned, not limited to it.
Therefore, a future work is to concretize the description of our implementation for TEE technologies other than Arm, e.g., Intel~SGX\@.
As described in \autoref{sec:significance}, the recent research of \ac{fTPM} and \ac{DICE} within the RISC-V ecosystem can also be synthesized with our design.

The system we propose can also be transferred from the \ac{DICE} architecture to other technologies that also perform firmware measurements.
A new technological framework that generalizes \ac{DICE} is Caliptra~\cite{caliptra}.
It is based on the concept of \ac{DICE}, but is not limited to it.

As mentioned in \autoref{sec:arch_overview}, RPMB's rollback protection only protects against attacks from outside the TEE\@.
We would like to establish a design that tightens the rollback protection from the trust of the entire TEE to the identity of the fTPM\@.
This can probably be achieved by encrypting the metadata stored on the RPMB with the storage key derived from the identity of the fTPM, i.e., its CDI, before sending it to the RPMB\@.
This must be implemented in the trusted operating system and not in the fTPM TA, as the trusted operating system normally manages the metadata.

Furthermore, our solution does not protect against runtime attacks on the fTPM\@.
In general, \acp{TA} in a \ac{TEE} are not resistant to security problems caused by programming errors, e.g., buffer overflow attacks.
Therefore, remote attestation of the control flow integrity of the fTPM may be a desired function.
Displaying the current state of the fTPM instead of its identity at boot time would be a useful extension to our solution.

% We described in \autoref{sec:impl_ftpm_attestation} the new fTPM TA command \texttt{TA\_FTPM\_ATTEST}.
% Instead store the certificate chain in the NV indices provided by EK profile.
% We didn't do it because it does not benefit the demonstration of our system, but requires much engineering effort. For example, tpm2_getekcertificate does not support that.
% But it would greatly simplify our solution. But it also takes NV index storage space, which is now not taken. But the fTPM still takes more space.
